From d9109c1495c286e4475e3906840204100a091fd2 Mon Sep 17 00:00:00 2001
From: "SM9()" <me@sm9.dev>
Date: Thu, 29 Jun 2023 13:38:56 +0100
Subject: [PATCH] high-hz

---
 arch/alpha/kernel/setup.c                     |   2 +-
 arch/alpha/kernel/smp.c                       |   2 +-
 arch/arc/kernel/setup.c                       |   2 +-
 arch/arm/kernel/setup.c                       |   4 +-
 arch/arm/kernel/smp.c                         |   2 +-
 arch/arm64/kernel/cpuinfo.c                   |   2 +-
 arch/ia64/kernel/smpboot.c                    |   2 +-
 arch/m68k/kernel/setup_mm.c                   |   2 +-
 arch/microblaze/kernel/cpu/mb.c               |   2 +-
 arch/mips/kernel/proc.c                       |   2 +-
 arch/openrisc/kernel/setup.c                  |   2 +-
 arch/parisc/kernel/processor.c                |   2 +-
 arch/powerpc/kernel/setup-common.c            |   4 +-
 arch/s390/kernel/processor.c                  |   2 +-
 arch/s390/kernel/sysinfo.c                    |   2 +-
 arch/sh/kernel/cpu/proc.c                     |   2 +-
 arch/sh/kernel/setup.c                        |   2 +-
 arch/sh/kernel/smp.c                          |   2 +-
 arch/sparc/kernel/cpu.c                       |   2 +-
 arch/sparc/kernel/smp_32.c                    |   4 +-
 arch/um/kernel/um_arch.c                      |   2 +-
 arch/x86/kernel/cpu/proc.c                    |   2 +-
 arch/x86/kernel/jailhouse.c                   |   2 +-
 arch/x86/kernel/smpboot.c                     |   2 +-
 arch/x86/kernel/tsc.c                         |   2 +-
 arch/xtensa/kernel/setup.c                    |   2 +-
 drivers/char/dtlk.c                           |   4 +-
 drivers/cpuidle/cpuidle.c                     |   4 +
 drivers/md/dm-integrity.c                     |   2 +-
 drivers/media/pci/ivtv/ivtv-streams.c         |   2 +-
 drivers/net/ethernet/micrel/ksz884x.c         |   4 +
 drivers/net/ethernet/xilinx/xilinx_emaclite.c |   2 +-
 drivers/net/fddi/defza.c                      |   8 +-
 drivers/net/wan/hdlc_cisco.c                  |   2 +-
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    |   4 +
 .../net/wireless/intersil/hostap/hostap_hw.c  |   2 +-
 .../wireless/intersil/orinoco/orinoco_usb.c   |   2 +-
 drivers/pcmcia/i82365.c                       |   2 +-
 drivers/pcmcia/tcic.c                         |   2 +-
 drivers/platform/chrome/cros_ec_lightbar.c    |   2 +-
 drivers/s390/char/diag_ftp.c                  |   2 +-
 drivers/s390/char/sclp_ftp.c                  |   2 +-
 drivers/s390/crypto/zcrypt_cex2c.c            |   4 +
 drivers/scsi/bnx2fc/bnx2fc_fcoe.c             |   4 +
 drivers/scsi/bnx2i/bnx2i_init.c               |   4 +
 drivers/watchdog/da9052_wdt.c                 |   2 +-
 include/net/tcp.h                             |   4 +-
 include/trace/events/writeback.h              |  10 +-
 init/calibrate.c                              |   2 +-
 kernel/Kconfig.hz                             | 162 +++++++++++++-----
 kernel/events/core.c                          |   4 +
 kernel/rcu/tree_nocb.h                        |   2 +-
 52 files changed, 205 insertions(+), 97 deletions(-)

diff --git a/arch/alpha/kernel/setup.c b/arch/alpha/kernel/setup.c
index 33bf3a62700270..6e3579b350b29c 100644
--- a/arch/alpha/kernel/setup.c
+++ b/arch/alpha/kernel/setup.c
@@ -1192,7 +1192,7 @@ show_cpuinfo(struct seq_file *f, void *slot)
 		       hwrpb->pa_bits,
 		       hwrpb->max_asn,
 		       loops_per_jiffy / (500000/HZ),
-		       (loops_per_jiffy / (5000/HZ)) % 100,
+		       (loops_per_jiffy * HZ) / 5000) % 100,
 		       unaligned[0].count, unaligned[0].pc, unaligned[0].va,
 		       unaligned[1].count, unaligned[1].pc, unaligned[1].va,
 		       platform_string(), nr_processors);
diff --git a/arch/alpha/kernel/smp.c b/arch/alpha/kernel/smp.c
index 7439b2377df579..6f78ba325ab15d 100644
--- a/arch/alpha/kernel/smp.c
+++ b/arch/alpha/kernel/smp.c
@@ -494,7 +494,7 @@ smp_cpus_done(unsigned int max_cpus)
 	       "(%lu.%02lu BogoMIPS).\n",
 	       num_online_cpus(), 
 	       (bogosum + 2500) / (500000/HZ),
-	       ((bogosum + 2500) / (5000/HZ)) % 100);
+	       (((bogosum + 2500) * HZ) / 5000) % 100);
 }
 
 static void
diff --git a/arch/arc/kernel/setup.c b/arch/arc/kernel/setup.c
index 41f07b3e594e0f..7cdf6647c4af58 100644
--- a/arch/arc/kernel/setup.c
+++ b/arch/arc/kernel/setup.c
@@ -644,7 +644,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 
 	seq_printf(m, "Bogo MIPS\t: %lu.%02lu\n",
 		   loops_per_jiffy / (500000 / HZ),
-		   (loops_per_jiffy / (5000 / HZ)) % 100);
+		   ((loops_per_jiffy * HZ) / 5000) % 100);
 
 	seq_printf(m, arc_mmu_mumbojumbo(cpu_id, str, PAGE_SIZE));
 	seq_printf(m, arc_cache_mumbojumbo(cpu_id, str, PAGE_SIZE));
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 75cd4699e7b3ee..38777863cf900d 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -1302,11 +1302,11 @@ static int c_show(struct seq_file *m, void *v)
 #if defined(CONFIG_SMP)
 		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
 			   per_cpu(cpu_data, i).loops_per_jiffy / (500000UL/HZ),
-			   (per_cpu(cpu_data, i).loops_per_jiffy / (5000UL/HZ)) % 100);
+			   ((per_cpu(cpu_data, i).loops_per_jiffy * HZ) / 5000UL) % 100);
 #else
 		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
 			   loops_per_jiffy / (500000/HZ),
-			   (loops_per_jiffy / (5000/HZ)) % 100);
+			   ((loops_per_jiffy * HZ) / 5000) % 100);
 #endif
 		/* dump out the processor features */
 		seq_puts(m, "Features\t: ");
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 87f8d0e5e314a8..5000a185c1b8fd 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -494,7 +494,7 @@ void __init smp_cpus_done(unsigned int max_cpus)
 	       "(%lu.%02lu BogoMIPS).\n",
 	       num_online_cpus(),
 	       bogosum / (500000/HZ),
-	       (bogosum / (5000/HZ)) % 100);
+	       ((bogosum * HZ) / 5000) % 100);
 
 	hyp_mode_check();
 }
diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c
index eb4378c23b3c3e..6db6caa396e216 100644
--- a/arch/arm64/kernel/cpuinfo.c
+++ b/arch/arm64/kernel/cpuinfo.c
@@ -193,7 +193,7 @@ static int c_show(struct seq_file *m, void *v)
 
 		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
 			   loops_per_jiffy / (500000UL/HZ),
-			   loops_per_jiffy / (5000UL/HZ) % 100);
+			   (loops_per_jiffy * HZ) / 5000UL % 100);
 
 		/*
 		 * Dump out the common processor features in a single line.
diff --git a/arch/ia64/kernel/smpboot.c b/arch/ia64/kernel/smpboot.c
index d0e935cf2093af..515951842ab340 100644
--- a/arch/ia64/kernel/smpboot.c
+++ b/arch/ia64/kernel/smpboot.c
@@ -688,7 +688,7 @@ smp_cpus_done (unsigned int dummy)
 	}
 
 	printk(KERN_INFO "Total of %d processors activated (%lu.%02lu BogoMIPS).\n",
-	       (int)num_online_cpus(), bogosum/(500000/HZ), (bogosum/(5000/HZ))%100);
+	       (int)num_online_cpus(), bogosum/(500000/HZ), ((bogosum*HZ)/5000)%100);
 }
 
 static inline void set_cpu_sibling_map(int cpu)
diff --git a/arch/m68k/kernel/setup_mm.c b/arch/m68k/kernel/setup_mm.c
index fbff1cea62caac..c9cbdab830d118 100644
--- a/arch/m68k/kernel/setup_mm.c
+++ b/arch/m68k/kernel/setup_mm.c
@@ -449,7 +449,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		   "Calibration:\t%lu loops\n",
 		   cpu, mmu, fpu,
 		   clockfreq/1000000,(clockfreq/100000)%10,
-		   loops_per_jiffy/(500000/HZ),(loops_per_jiffy/(5000/HZ))%100,
+		   loops_per_jiffy/(500000/HZ),((loops_per_jiffy*HZ)/5000)%100,
 		   loops_per_jiffy);
 	return 0;
 }
diff --git a/arch/microblaze/kernel/cpu/mb.c b/arch/microblaze/kernel/cpu/mb.c
index 9581d194d9e479..5c88d0e327fab6 100644
--- a/arch/microblaze/kernel/cpu/mb.c
+++ b/arch/microblaze/kernel/cpu/mb.c
@@ -59,7 +59,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		   cpuinfo.cpu_clock_freq / 1000000,
 		   cpuinfo.cpu_clock_freq % 1000000,
 		   loops_per_jiffy / (500000 / HZ),
-		   (loops_per_jiffy / (5000 / HZ)) % 100);
+		   ((loops_per_jiffy * HZ) / 5000) % 100);
 
 	seq_printf(m,
 		   "HW:\n Shift:\t\t%s\n"
diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
index 8eba5a1ed664c4..6dd6abc88cabdd 100644
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -65,7 +65,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		      (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
 	seq_printf(m, "BogoMIPS\t\t: %u.%02u\n",
 		      cpu_data[n].udelay_val / (500000/HZ),
-		      (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+		      ((cpu_data[n].udelay_val * HZ) / 5000) % 100);
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 		      cpu_has_counter ? "yes" : "no");
diff --git a/arch/openrisc/kernel/setup.c b/arch/openrisc/kernel/setup.c
index 9cf7fb60441f89..875febbb34327d 100644
--- a/arch/openrisc/kernel/setup.c
+++ b/arch/openrisc/kernel/setup.c
@@ -248,7 +248,7 @@ void calibrate_delay(void)
 	loops_per_jiffy = *val / HZ;
 	pr_cont("%lu.%02lu BogoMIPS (lpj=%lu)\n",
 		loops_per_jiffy / (500000 / HZ),
-		(loops_per_jiffy / (5000 / HZ)) % 100, loops_per_jiffy);
+		((loops_per_jiffy * HZ) / 5000) % 100, loops_per_jiffy);
 
 	of_node_put(cpu);
 }
diff --git a/arch/parisc/kernel/processor.c b/arch/parisc/kernel/processor.c
index ba07e760d3c762..d24b3388fb8375 100644
--- a/arch/parisc/kernel/processor.c
+++ b/arch/parisc/kernel/processor.c
@@ -438,7 +438,7 @@ show_cpuinfo (struct seq_file *m, void *v)
 
 		seq_printf(m, "bogomips\t: %lu.%02lu\n",
 			     loops_per_jiffy / (500000 / HZ),
-			     loops_per_jiffy / (5000 / HZ) % 100);
+			     (loops_per_jiffy * HZ) / 5000 % 100);
 
 		seq_printf(m, "software id\t: %ld\n\n",
 				boot_cpu_data.pdc.model.sw_id);
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index d2a446216444f2..cc80d05c781498 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -211,7 +211,7 @@ static void show_cpuinfo_summary(struct seq_file *m)
 		for_each_online_cpu(i)
 			bogosum += loops_per_jiffy;
 		seq_printf(m, "total bogomips\t: %lu.%02lu\n",
-			   bogosum / (500000 / HZ), bogosum / (5000 / HZ) % 100);
+			   bogosum / (500000 / HZ), (bogosum * HZ) / 5000 % 100);
 	}
 	seq_printf(m, "timebase\t: %lu\n", ppc_tb_freq);
 	if (ppc_md.name)
@@ -332,7 +332,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 
 	if (IS_ENABLED(CONFIG_PPC32))
 		seq_printf(m, "bogomips\t: %lu.%02lu\n", loops_per_jiffy / (500000 / HZ),
-			   (loops_per_jiffy / (5000 / HZ)) % 100);
+			   ((loops_per_jiffy * HZ) / 5000) % 100);
 
 	seq_putc(m, '\n');
 
diff --git a/arch/s390/kernel/processor.c b/arch/s390/kernel/processor.c
index 0a999c8226d733..6755ced35b8d14 100644
--- a/arch/s390/kernel/processor.c
+++ b/arch/s390/kernel/processor.c
@@ -139,7 +139,7 @@ static void show_cpu_summary(struct seq_file *m, void *v)
 		   "# processors    : %i\n"
 		   "bogomips per cpu: %lu.%02lu\n",
 		   num_online_cpus(), loops_per_jiffy/(500000/HZ),
-		   (loops_per_jiffy/(5000/HZ))%100);
+		   ((loops_per_jiffy*HZ)/5000)%100);
 	seq_printf(m, "max thread id   : %d\n", smp_cpu_mtid);
 	seq_puts(m, "features\t: ");
 	for (i = 0; i < ARRAY_SIZE(hwcap_str); i++)
diff --git a/arch/s390/kernel/sysinfo.c b/arch/s390/kernel/sysinfo.c
index b5e364358ce43a..0e6e31ef158f43 100644
--- a/arch/s390/kernel/sysinfo.c
+++ b/arch/s390/kernel/sysinfo.c
@@ -472,7 +472,7 @@ void calibrate_delay(void)
 	/* Print the good old Bogomips line .. */
 	printk(KERN_DEBUG "Calibrating delay loop (skipped)... "
 	       "%lu.%02lu BogoMIPS preset\n", loops_per_jiffy/(500000/HZ),
-	       (loops_per_jiffy/(5000/HZ)) % 100);
+	       ((loops_per_jiffy*HZ)/5000) % 100);
 }
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/arch/sh/kernel/cpu/proc.c b/arch/sh/kernel/cpu/proc.c
index a306bcd6b34130..00087283e89c58 100644
--- a/arch/sh/kernel/cpu/proc.c
+++ b/arch/sh/kernel/cpu/proc.c
@@ -125,7 +125,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 
 	seq_printf(m, "bogomips\t: %lu.%02lu\n",
 		     c->loops_per_jiffy/(500000/HZ),
-		     (c->loops_per_jiffy/(5000/HZ)) % 100);
+		     ((c->loops_per_jiffy*HZ)/5000) % 100);
 
 	return 0;
 }
diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
index af977ec4ca5e5b..d6bc91cfe6e7ba 100644
--- a/arch/sh/kernel/setup.c
+++ b/arch/sh/kernel/setup.c
@@ -189,7 +189,7 @@ void calibrate_delay(void)
 	printk(KERN_INFO "Calibrating delay loop (skipped)... "
 			 "%lu.%02lu BogoMIPS PRESET (lpj=%lu)\n",
 			 loops_per_jiffy/(500000/HZ),
-			 (loops_per_jiffy/(5000/HZ)) % 100,
+			 ((loops_per_jiffy*HZ)/5000) % 100,
 			 loops_per_jiffy);
 }
 #endif
diff --git a/arch/sh/kernel/smp.c b/arch/sh/kernel/smp.c
index 5cf35a774dc700..84e0e23309379d 100644
--- a/arch/sh/kernel/smp.c
+++ b/arch/sh/kernel/smp.c
@@ -253,7 +253,7 @@ void __init smp_cpus_done(unsigned int max_cpus)
 	printk(KERN_INFO "SMP: Total of %d processors activated "
 	       "(%lu.%02lu BogoMIPS).\n", num_online_cpus(),
 	       bogosum / (500000/HZ),
-	       (bogosum / (5000/HZ)) % 100);
+	       ((bogosum * HZ) / 5000) % 100);
 }
 
 void arch_smp_send_reschedule(int cpu)
diff --git a/arch/sparc/kernel/cpu.c b/arch/sparc/kernel/cpu.c
index 79cd6ccfeac06f..d41ae22b743e8d 100644
--- a/arch/sparc/kernel/cpu.c
+++ b/arch/sparc/kernel/cpu.c
@@ -346,7 +346,7 @@ static int show_cpuinfo(struct seq_file *m, void *__unused)
 		   num_online_cpus()
 #ifndef CONFIG_SMP
 		   , cpu_data(0).udelay_val/(500000/HZ),
-		   (cpu_data(0).udelay_val/(5000/HZ)) % 100,
+		   ((cpu_data(0).udelay_val * HZ)/5000) % 100,
 		   cpu_data(0).clock_tick
 #endif
 		);
diff --git a/arch/sparc/kernel/smp_32.c b/arch/sparc/kernel/smp_32.c
index 87eaa7719fa27a..52caafe2d879a1 100644
--- a/arch/sparc/kernel/smp_32.c
+++ b/arch/sparc/kernel/smp_32.c
@@ -85,7 +85,7 @@ void __init smp_cpus_done(unsigned int max_cpus)
 
 	printk("Total of %d processors activated (%lu.%02lu BogoMIPS).\n",
 		num, bogosum/(500000/HZ),
-		(bogosum/(5000/HZ))%100);
+		((bogosum*HZ)/5000)%100);
 
 	switch(sparc_cpu_model) {
 	case sun4m:
@@ -375,7 +375,7 @@ void smp_bogo(struct seq_file *m)
 			   "Cpu%dBogo\t: %lu.%02lu\n",
 			   i,
 			   cpu_data(i).udelay_val/(500000/HZ),
-			   (cpu_data(i).udelay_val/(5000/HZ))%100);
+			   ((cpu_data(i).udelay_val*HZ)/5000)%100);
 	}
 }
 
diff --git a/arch/um/kernel/um_arch.c b/arch/um/kernel/um_arch.c
index 0a23a98d4ca0a7..9b7f26e1609583 100644
--- a/arch/um/kernel/um_arch.c
+++ b/arch/um/kernel/um_arch.c
@@ -88,7 +88,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	seq_printf(m, "cache_alignment\t: %d\n", boot_cpu_data.cache_alignment);
 	seq_printf(m, "bogomips\t: %lu.%02lu\n",
 		   loops_per_jiffy/(500000/HZ),
-		   (loops_per_jiffy/(5000/HZ)) % 100);
+		   ((loops_per_jiffy*HZ)/5000) % 100);
 
 
 	return 0;
diff --git a/arch/x86/kernel/cpu/proc.c b/arch/x86/kernel/cpu/proc.c
index 099b6f0d96bdc1..977bb9fba16500 100644
--- a/arch/x86/kernel/cpu/proc.c
+++ b/arch/x86/kernel/cpu/proc.c
@@ -122,7 +122,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 
 	seq_printf(m, "\nbogomips\t: %lu.%02lu\n",
 		   c->loops_per_jiffy/(500000/HZ),
-		   (c->loops_per_jiffy/(5000/HZ)) % 100);
+		   ((c->loops_per_jiffy*HZ)/5000) % 100);
 
 #ifdef CONFIG_X86_64
 	if (c->x86_tlbsize > 0)
diff --git a/arch/x86/kernel/jailhouse.c b/arch/x86/kernel/jailhouse.c
index 4eb8f2d19a872f..d1b3f25c65fc66 100644
--- a/arch/x86/kernel/jailhouse.c
+++ b/arch/x86/kernel/jailhouse.c
@@ -63,7 +63,7 @@ static void jailhouse_get_wallclock(struct timespec64 *now)
 
 static void __init jailhouse_timer_init(void)
 {
-	lapic_timer_period = setup_data.v1.apic_khz * (1000 / HZ);
+	lapic_timer_period = (setup_data.v1.apic_khz * 1000) / HZ;
 }
 
 static unsigned long jailhouse_get_tsc(void)
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 34066f6735ddf8..3cae1d92907748 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -712,7 +712,7 @@ static void impress_friends(void)
 	pr_info("Total of %d processors activated (%lu.%02lu BogoMIPS)\n",
 		num_online_cpus(),
 		bogosum/(500000/HZ),
-		(bogosum/(5000/HZ))%100);
+		((bogosum*HZ)/5000)%100);
 
 	pr_debug("Before bogocount - setting activated=1\n");
 }
diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index 3446988521466a..8f39bbcf231a48 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -703,7 +703,7 @@ unsigned long native_calibrate_tsc(void)
 	 * lapic_timer_period here to avoid having to calibrate the APIC
 	 * timer later.
 	 */
-	lapic_timer_period = crystal_khz * 1000 / HZ;
+	lapic_timer_period = (crystal_khz * 1000) / HZ;
 #endif
 
 	return crystal_khz * ebx_numerator / eax_denominator;
diff --git a/arch/xtensa/kernel/setup.c b/arch/xtensa/kernel/setup.c
index 9191738f99413a..4dbda747b47531 100644
--- a/arch/xtensa/kernel/setup.c
+++ b/arch/xtensa/kernel/setup.c
@@ -564,7 +564,7 @@ c_show(struct seq_file *f, void *slot)
 		      ccount_freq/1000000,
 		      (ccount_freq/10000) % 100,
 		      loops_per_jiffy/(500000/HZ),
-		      (loops_per_jiffy/(5000/HZ)) % 100);
+		      ((loops_per_jiffy*HZ)/5000) % 100);
 	seq_puts(f, "flags\t\t: "
 #if XCHAL_HAVE_NMI
 		     "nmi "
diff --git a/drivers/char/dtlk.c b/drivers/char/dtlk.c
index 6946c1cad9f6a1..8228122837a6fd 100644
--- a/drivers/char/dtlk.c
+++ b/drivers/char/dtlk.c
@@ -201,7 +201,7 @@ static ssize_t dtlk_write(struct file *file, const char __user *buf,
 				   up to 250 usec for the RDY bit to
 				   go nonzero. */
 				for (retries = 0;
-				     retries < loops_per_jiffy / (4000/HZ);
+				     retries < (loops_per_jiffy * HZ) / 4000;
 				     retries++)
 					if (inb_p(dtlk_port_tts) &
 					    TTS_WRITABLE)
@@ -449,7 +449,7 @@ for (i = 0; i < 10; i++)			\
 				LOOK
 				dtlk_write_bytes("\0012I\r", 4);
 				buffer[b++] = 0;
-				__delay(50 * loops_per_jiffy / (1000/HZ));
+				__delay(50 * (loops_per_jiffy * HZ) / 1000);
 				outb_p(0xff, dtlk_port_lpc);
 				buffer[b++] = 0;
 				LOOK
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 8e929f6602cef5..9564b8a2f40e84 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -416,7 +416,11 @@ void cpuidle_reflect(struct cpuidle_device *dev, int index)
  * Run multiple times to avoid cpufreq effects.
  */
 #define CPUIDLE_POLL_MIN 10000
+#if HZ > 1666
+#define CPUIDLE_POLL_MAX 18750
+#else
 #define CPUIDLE_POLL_MAX (TICK_NSEC / 16)
+#endif
 
 /**
  * cpuidle_poll_time - return amount of time to poll for,
diff --git a/drivers/md/dm-integrity.c b/drivers/md/dm-integrity.c
index 31838b13ea5434..b0ec37fc58b048 100644
--- a/drivers/md/dm-integrity.c
+++ b/drivers/md/dm-integrity.c
@@ -4145,7 +4145,7 @@ static int dm_integrity_ctr(struct dm_target *ti, unsigned int argc, char **argv
 		} else if (sscanf(opt_string, "sectors_per_bit:%llu%c", &llval, &dummy) == 1) {
 			log2_sectors_per_bitmap_bit = !llval ? 0 : __ilog2_u64(llval);
 		} else if (sscanf(opt_string, "bitmap_flush_interval:%u%c", &val, &dummy) == 1) {
-			if (val >= (uint64_t)UINT_MAX * 1000 / HZ) {
+			if (val >= ((uint64_t)UINT_MAX * 1000) / HZ) {
 				r = -EINVAL;
 				ti->error = "Invalid bitmap_flush_interval argument";
 				goto bad;
diff --git a/drivers/media/pci/ivtv/ivtv-streams.c b/drivers/media/pci/ivtv/ivtv-streams.c
index 13d7d55e659490..ed5765c83b9f1b 100644
--- a/drivers/media/pci/ivtv/ivtv-streams.c
+++ b/drivers/media/pci/ivtv/ivtv-streams.c
@@ -856,7 +856,7 @@ int ivtv_stop_v4l2_encode_stream(struct ivtv_stream *s, int gop_end)
 			 * accuracy if we do a rounding calculation of the constant.
 			 * Think of the case where HZ is 1024.
 			 */
-			duration = ((1000 + HZ / 2) / HZ) * (jiffies - then);
+			duration = ((1000 + HZ / 2) * (jiffies - then)) / HZ;
 
 			if (!test_bit(IVTV_F_I_EOS, &itv->i_flags)) {
 				IVTV_DEBUG_WARN("%s: EOS interrupt not received! stopping anyway.\n", s->name);
diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c
index c5aeeb964c17a8..e862c848d0a7b7 100644
--- a/drivers/net/ethernet/micrel/ksz884x.c
+++ b/drivers/net/ethernet/micrel/ksz884x.c
@@ -5014,7 +5014,11 @@ static int netdev_close(struct net_device *dev)
 		hw_clr_multicast(hw);
 
 		/* Delay for receive task to stop scheduling itself. */
+#if HZ >= 2000
+		msleep(1);
+#else
 		msleep(2000 / HZ);
+#endif
 
 		tasklet_kill(&hw_priv->rx_tasklet);
 		tasklet_kill(&hw_priv->tx_tasklet);
diff --git a/drivers/net/ethernet/xilinx/xilinx_emaclite.c b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
index ad2c30d9a48248..7c641c71d50e7b 100644
--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
@@ -522,7 +522,7 @@ static void xemaclite_tx_timeout(struct net_device *dev, unsigned int txqueue)
 	unsigned long flags;
 
 	dev_err(&lp->ndev->dev, "Exceeded transmit timeout of %lu ms\n",
-		TX_TIMEOUT * 1000UL / HZ);
+		(TX_TIMEOUT * 1000UL) / HZ);
 
 	dev->stats.tx_errors++;
 
diff --git a/drivers/net/fddi/defza.c b/drivers/net/fddi/defza.c
index f5c25acaa57713..76ca849fd8bbaf 100644
--- a/drivers/net/fddi/defza.c
+++ b/drivers/net/fddi/defza.c
@@ -277,7 +277,7 @@ static int fza_reset(struct fza_private *fp)
 	}
 	pr_info("%s: OK\n", fp->name);
 	pr_debug("%s: RESET: %lums elapsed\n", fp->name,
-		 (45 * HZ - t) * 1000 / HZ);
+		 ((45 * HZ - t) * 1000) / HZ);
 
 	return 0;
 }
@@ -408,7 +408,7 @@ static int fza_init_send(struct net_device *dev,
 		return -EIO;
 	}
 	pr_debug("%s: INIT: %lums elapsed\n", fp->name,
-		 (3 * HZ - t) * 1000 / HZ);
+		 ((3 * HZ - t) * 1000) / HZ);
 
 	if (init)
 		*init = fp->mmio + readl_u(&ring->buffer);
@@ -1211,7 +1211,7 @@ static int fza_open(struct net_device *dev)
 		return -EIO;
 	}
 	pr_debug("%s: PARAM: %lums elapsed\n", fp->name,
-		 (3 * HZ - t) * 1000 / HZ);
+		 ((3 * HZ - t) * 1000) / HZ);
 
 	return 0;
 }
@@ -1249,7 +1249,7 @@ static int fza_close(struct net_device *dev)
 		return -EIO;
 	}
 	pr_debug("%s: SHUT: %lums elapsed\n", fp->name,
-		 (15 * HZ - t) * 1000 / HZ);
+		 ((15 * HZ - t) * 1000) / HZ);
 
 	for (i = 0; i < FZA_RING_RX_SIZE; i++)
 		if (fp->rx_skbuff[i]) {
diff --git a/drivers/net/wan/hdlc_cisco.c b/drivers/net/wan/hdlc_cisco.c
index cdebe65a7e2d0c..aa9b65557ec39b 100644
--- a/drivers/net/wan/hdlc_cisco.c
+++ b/drivers/net/wan/hdlc_cisco.c
@@ -104,7 +104,7 @@ static void cisco_keepalive_send(struct net_device *dev, u32 type,
 	data->par2 = par2;
 	data->rel = cpu_to_be16(0xFFFF);
 	/* we will need do_div here if 1000 % HZ != 0 */
-	data->time = htonl((jiffies - INITIAL_JIFFIES) * (1000 / HZ));
+	data->time = (htonl((jiffies - INITIAL_JIFFIES) * 1000) / HZ);
 
 	skb_put(skb, sizeof(struct cisco_packet));
 	skb->priority = TC_PRIO_CONTROL;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index de8a2e27f49c73..c79095c856f6ee 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -3973,7 +3973,11 @@ static int brcmf_cfg80211_sched_scan_stop(struct wiphy *wiphy,
 
 static __always_inline void brcmf_delay(u32 ms)
 {
+#if HZ >= 1000
+	if (ms < 1) {
+#else
 	if (ms < 1000 / HZ) {
+#endif
 		cond_resched();
 		mdelay(ms);
 	} else {
diff --git a/drivers/net/wireless/intersil/hostap/hostap_hw.c b/drivers/net/wireless/intersil/hostap/hostap_hw.c
index b74f4cb5d6d399..b049b54d407c6c 100644
--- a/drivers/net/wireless/intersil/hostap/hostap_hw.c
+++ b/drivers/net/wireless/intersil/hostap/hostap_hw.c
@@ -1326,7 +1326,7 @@ static int prism2_hw_init(struct net_device *dev, int initial)
 	}
 	local->no_pri = 0;
 	printk(KERN_DEBUG "prism2_hw_init: initialized in %lu ms\n",
-	       (jiffies - start) * 1000 / HZ);
+	       ((jiffies - start) * 1000) / HZ);
 	HFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);
 	return 0;
 }
diff --git a/drivers/net/wireless/intersil/orinoco/orinoco_usb.c b/drivers/net/wireless/intersil/orinoco/orinoco_usb.c
index dd31929261ab9f..4181f0fa761c95 100644
--- a/drivers/net/wireless/intersil/orinoco/orinoco_usb.c
+++ b/drivers/net/wireless/intersil/orinoco/orinoco_usb.c
@@ -698,7 +698,7 @@ static void ezusb_req_ctx_wait_poll(struct ezusb_priv *upriv,
 		 * happen if the USB controller completes the URB requests in
 		 * BH.
 		 */
-		msecs = DEF_TIMEOUT * (1000 / HZ);
+		msecs = (DEF_TIMEOUT * 1000) / HZ;
 
 		while (!try_wait_for_completion(&ctx->done) && msecs--)
 			udelay(1000);
diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 891ccea2cccb0a..705c04f7b951ed 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -719,7 +719,7 @@ static void __init add_pcic(int ns, int type)
 	if (poll_interval == 0)
 	    poll_interval = HZ;
 	printk(" polling interval = %d ms\n",
-	       poll_interval * 1000 / HZ);
+	       (poll_interval * 1000) / HZ);
 	
     }
     
diff --git a/drivers/pcmcia/tcic.c b/drivers/pcmcia/tcic.c
index 1a0e3f0987599d..3276d384df01fd 100644
--- a/drivers/pcmcia/tcic.c
+++ b/drivers/pcmcia/tcic.c
@@ -476,7 +476,7 @@ static int __init init_tcic(void)
 	printk("status change on irq %d\n", cs_irq);
     else
 	printk("polled status, interval = %d ms\n",
-	       poll_interval * 1000 / HZ);
+	       (poll_interval * 1000) / HZ);
     
     for (i = 0; i < sockets; i++) {
 	tcic_setw(TCIC_ADDR+2, socket_table[i].psock << TCIC_SS_SHFT);
diff --git a/drivers/platform/chrome/cros_ec_lightbar.c b/drivers/platform/chrome/cros_ec_lightbar.c
index 376425bbd8ffb6..283b34dc9d866e 100644
--- a/drivers/platform/chrome/cros_ec_lightbar.c
+++ b/drivers/platform/chrome/cros_ec_lightbar.c
@@ -32,7 +32,7 @@ static bool userspace_control;
 static ssize_t interval_msec_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
-	unsigned long msec = lb_interval_jiffies * 1000 / HZ;
+	unsigned long msec = (lb_interval_jiffies * 1000) / HZ;
 
 	return sysfs_emit(buf, "%lu\n", msec);
 }
diff --git a/drivers/s390/char/diag_ftp.c b/drivers/s390/char/diag_ftp.c
index 65c7f2d565d806..66dad0e3ce954c 100644
--- a/drivers/s390/char/diag_ftp.c
+++ b/drivers/s390/char/diag_ftp.c
@@ -183,7 +183,7 @@ ssize_t diag_ftp_cmd(const struct hmcdrv_ftp_cmdspec *ftp, size_t *fsize)
 
 #ifdef DEBUG
 	pr_debug("completed DIAG X'2C4' after %lu ms\n",
-		 (jiffies - start_jiffies) * 1000 / HZ);
+		 ((jiffies - start_jiffies) * 1000) / HZ);
 	pr_debug("status of DIAG X'2C4' is %u, with %lld/%lld bytes\n",
 		 diag_ftp_subcode, ldfpl->transferred, ldfpl->fsize);
 #endif
diff --git a/drivers/s390/char/sclp_ftp.c b/drivers/s390/char/sclp_ftp.c
index d27e2cbfbccb38..a8e0e01cea0b7f 100644
--- a/drivers/s390/char/sclp_ftp.c
+++ b/drivers/s390/char/sclp_ftp.c
@@ -197,7 +197,7 @@ ssize_t sclp_ftp_cmd(const struct hmcdrv_ftp_cmdspec *ftp, size_t *fsize)
 
 #ifdef DEBUG
 	pr_debug("completed SCLP (ET7) request after %lu ms (all)\n",
-		 (jiffies - start_jiffies) * 1000 / HZ);
+		 ((jiffies - start_jiffies) * 1000) / HZ);
 	pr_debug("return code of SCLP (ET7) FTP Service is 0x%02x, with %lld/%lld bytes\n",
 		 sclp_ftp_ldflg, sclp_ftp_length, sclp_ftp_fsize);
 #endif
diff --git a/drivers/s390/crypto/zcrypt_cex2c.c b/drivers/s390/crypto/zcrypt_cex2c.c
index 251b5bd3d19c28..022cbae929a9d0 100644
--- a/drivers/s390/crypto/zcrypt_cex2c.c
+++ b/drivers/s390/crypto/zcrypt_cex2c.c
@@ -211,7 +211,11 @@ static int zcrypt_cex2c_rng_supported(struct ap_queue *aq)
 
 	/* Wait for the test message to complete. */
 	for (i = 0; i < 2 * HZ; i++) {
+#if HZ >= 1000
+		msleep(1);
+#else
 		msleep(1000 / HZ);
+#endif
 		rc = ap_recv(aq->qid, &psmid, ap_msg.msg, ap_msg.bufsize);
 		if (rc == 0 && psmid == 0x0102030405060708UL)
 			break;
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 05ddbb9bb7d8aa..26adfff2c176e6 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -1881,7 +1881,11 @@ static void bnx2fc_stop(struct bnx2fc_interface *interface)
 
 static int bnx2fc_fw_init(struct bnx2fc_hba *hba)
 {
+#if HZ >= 1000
+#define BNX2FC_INIT_POLL_TIME		1
+#else
 #define BNX2FC_INIT_POLL_TIME		(1000 / HZ)
+#endif
 	int rc = -1;
 	int i = HZ;
 
diff --git a/drivers/scsi/bnx2i/bnx2i_init.c b/drivers/scsi/bnx2i/bnx2i_init.c
index 2b3f0c10478e3e..1f29ba43acfbdc 100644
--- a/drivers/scsi/bnx2i/bnx2i_init.c
+++ b/drivers/scsi/bnx2i/bnx2i_init.c
@@ -162,7 +162,11 @@ struct bnx2i_hba *bnx2i_find_hba_for_cnic(struct cnic_dev *cnic)
  */
 void bnx2i_start(void *handle)
 {
+#if HZ >= 1000
+#define BNX2I_INIT_POLL_TIME	1
+#else
 #define BNX2I_INIT_POLL_TIME	(1000 / HZ)
+#endif
 	struct bnx2i_hba *hba = handle;
 	int i = HZ;
 
diff --git a/drivers/watchdog/da9052_wdt.c b/drivers/watchdog/da9052_wdt.c
index d708c091bf1b1e..9e3bef0035d124 100644
--- a/drivers/watchdog/da9052_wdt.c
+++ b/drivers/watchdog/da9052_wdt.c
@@ -116,7 +116,7 @@ static int da9052_wdt_ping(struct watchdog_device *wdt_dev)
 	 * We have a minimum time for watchdog window called TWDMIN. A write
 	 * to the watchdog before this elapsed time should cause an error.
 	 */
-	msec = (jnow - driver_data->jpast) * 1000/HZ;
+	msec = ((jnow - driver_data->jpast) * 1000)/HZ;
 	if (msec < DA9052_TWDMIN)
 		mdelay(msec);
 
diff --git a/include/net/tcp.h b/include/net/tcp.h
index b3466120431579..cd9dc3206655b8 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -1635,8 +1635,8 @@ static inline void tcp_mib_init(struct net *net)
 {
 	/* See RFC 2012 */
 	TCP_ADD_STATS(net, TCP_MIB_RTOALGORITHM, 1);
-	TCP_ADD_STATS(net, TCP_MIB_RTOMIN, TCP_RTO_MIN*1000/HZ);
-	TCP_ADD_STATS(net, TCP_MIB_RTOMAX, TCP_RTO_MAX*1000/HZ);
+	TCP_ADD_STATS(net, TCP_MIB_RTOMIN, (TCP_RTO_MIN*1000)/HZ);
+	TCP_ADD_STATS(net, TCP_MIB_RTOMAX, (TCP_RTO_MAX/HZ)*1000);
 	TCP_ADD_STATS(net, TCP_MIB_MAXCONN, -1);
 }
 
diff --git a/include/trace/events/writeback.h b/include/trace/events/writeback.h
index 54e353c9f919fc..81dc831fd19021 100644
--- a/include/trace/events/writeback.h
+++ b/include/trace/events/writeback.h
@@ -512,7 +512,7 @@ TRACE_EVENT(writeback_queue_io,
 	TP_fast_assign(
 		strscpy_pad(__entry->name, bdi_dev_name(wb->bdi), 32);
 		__entry->older	= dirtied_before;
-		__entry->age	= (jiffies - dirtied_before) * 1000 / HZ;
+		__entry->age	= ((jiffies - dirtied_before) * 1000) / HZ;
 		__entry->moved	= moved;
 		__entry->reason	= work->reason;
 		__entry->cgroup_ino	= __trace_wb_assign_cgroup(wb);
@@ -671,10 +671,10 @@ TRACE_EVENT(balance_dirty_pages,
 		__entry->dirtied	= dirtied;
 		__entry->dirtied_pause	= current->nr_dirtied_pause;
 		__entry->think		= current->dirty_paused_when == 0 ? 0 :
-			 (long)(jiffies - current->dirty_paused_when) * 1000/HZ;
-		__entry->period		= period * 1000 / HZ;
-		__entry->pause		= pause * 1000 / HZ;
-		__entry->paused		= (jiffies - start_time) * 1000 / HZ;
+			 ((long)(jiffies - current->dirty_paused_when) * 1000)/HZ;
+		__entry->period		= (period * 1000) / HZ;
+		__entry->pause		= (pause * 1000) / HZ;
+		__entry->paused		= ((jiffies - start_time) * 1000) / HZ;
 		__entry->cgroup_ino	= __trace_wb_assign_cgroup(wb);
 	),
 
diff --git a/init/calibrate.c b/init/calibrate.c
index f3831272f11357..27aeb94e050b81 100644
--- a/init/calibrate.c
+++ b/init/calibrate.c
@@ -307,7 +307,7 @@ void calibrate_delay(void)
 	if (!printed)
 		pr_cont("%lu.%02lu BogoMIPS (lpj=%lu)\n",
 			lpj/(500000/HZ),
-			(lpj/(5000/HZ)) % 100, lpj);
+			((lpj*HZ)/5000) % 100, lpj);
 
 	loops_per_jiffy = lpj;
 	printed = true;
diff --git a/kernel/Kconfig.hz b/kernel/Kconfig.hz
index 0f78364efd4f23..6a3aeaa1f3ca87 100644
--- a/kernel/Kconfig.hz
+++ b/kernel/Kconfig.hz
@@ -1,71 +1,146 @@
 # SPDX-License-Identifier: GPL-2.0-only
 #
 # Timer Interrupt Frequency Configuration
-#
 
 choice
-	prompt "Timer frequency"
+	prompt "Timer Frequency"
 	default HZ_250
 	help
-	 Allows the configuration of the timer frequency. It is customary
-	 to have the timer interrupt run at 1000 Hz but 100 Hz may be more
-	 beneficial for servers and NUMA systems that do not need to have
-	 a fast response for user interaction and that may experience bus
-	 contention and cacheline bounces as a result of timer interrupts.
-	 Note that the timer interrupt occurs on each processor in an SMP
-	 environment leading to NR_CPUS * HZ number of timer interrupts
-	 per second.
-
+	 Select the desired timer frequency. The timer interrupt frequency determines
+	 how often the system generates interrupts to handle time-related tasks.
+	 Different frequencies offer trade-offs between interactive responsiveness,
+	 system stability, power consumption, and overall system performance.
 
 	config HZ_100
-		bool "100 HZ"
+		bool "100 Hz"
 	help
-	  100 Hz is a typical choice for servers, SMP and NUMA systems
-	  with lots of processors that may show reduced performance if
-	  too many timer interrupts are occurring.
+	  Select 100 Hz for servers, symmetric multiprocessing (SMP), and non-uniform
+	  memory access (NUMA) systems with multiple processors. This choice reduces
+	  interrupt overhead and enhances overall system stability. It is particularly
+	  suitable for scenarios where quick user interaction is not crucial, such as
+	  servers handling heavy workloads without immediate user feedback. It provides
+	  a balanced performance level for background tasks and workloads that do not
+	  require real-time responsiveness.
 
 	config HZ_250
-		bool "250 HZ"
+		bool "250 Hz"
 	help
-	 250 Hz is a good compromise choice allowing server performance
-	 while also showing good interactive responsiveness even
-	 on SMP and NUMA systems. If you are going to be using NTSC video
-	 or multimedia, selected 300Hz instead.
+	 Select 250 Hz as a balanced option suitable for a wide range of scenarios.
+	 It provides a compromise between interrupt frequency, server performance,
+	 and interactive responsiveness. This choice ensures smooth execution of
+	 server workloads while maintaining satisfactory interactive response times.
+	 It is suitable for general-purpose computing scenarios where a balance
+	 between system performance and interactivity is required. Examples include
+	 web servers, database servers, and cloud infrastructure.
 
 	config HZ_300
-		bool "300 HZ"
+		bool "300 Hz"
 	help
-	 300 Hz is a good compromise choice allowing server performance
-	 while also showing good interactive responsiveness even
-	 on SMP and NUMA systems and exactly dividing by both PAL and
-	 NTSC frame rates for video and multimedia work.
+	 Select 300 Hz to strike a balance between server performance and interactive
+	 responsiveness. This choice works well on SMP and NUMA systems and offers
+	 improved interactivity compared to lower frequencies. It is suitable for
+	 various workloads, including multimedia applications that require smoother
+	 interactive experiences. Examples include media streaming servers or video
+	 conferencing platforms.
 
 	config HZ_500
-		bool "500 HZ"
+		bool "500 Hz"
 	help
-	 500 Hz is a balanced timer frequency. Provides fast interactivity
-	 on desktops with good smoothness without increasing CPU power
-	 consumption and sacrificing the battery life on laptops.
+	 Select 500 Hz for a balanced timer frequency that prioritizes both responsiveness
+	 and energy efficiency. It provides fast interactivity on desktop systems without
+	 significantly increasing power consumption or sacrificing battery life on laptops.
+	 This choice is suitable for general-purpose computing scenarios where quick
+	 user feedback is desirable. Examples include personal computers or laptops used
+	 for web browsing, document editing, and general multitasking.
 
 	config HZ_600
-		bool "600 HZ"
+		bool "600 Hz"
 	help
-	 600 Hz is a balanced timer frequency. Provides fast interactivity
-	 on desktops with good smoothness without increasing CPU power
-	 consumption and sacrificing the battery life on laptops.
+	 Select 600 Hz for a balanced timer frequency that maintains fast interactivity
+	 on desktop systems. It offers a slight boost in responsiveness compared to lower
+	 frequencies without substantially increasing power consumption or sacrificing
+	 battery life on laptops. This choice is suitable for a wide range of computing
+	 tasks, including interactive applications and multitasking scenarios. Examples
+	 include gaming systems, graphical design workstations, or software development
+	 environments.
 
 	config HZ_750
-		bool "750 HZ"
+		bool "750 Hz"
+	help
+	 Select 750 Hz for a balanced timer frequency that ensures fast interactivity
+	 on desktop systems. It provides improved responsiveness compared to lower
+	 frequencies without substantially increasing power consumption or sacrificing
+	 battery life on laptops. This choice is suitable for interactive workloads
+	 and applications that require quick user feedback, such as gaming or real-time
+	 simulations. Examples include real-time strategy games or virtual reality
+	 applications.
+
+	config HZ_833
+		bool "833 Hz"
 	help
-	 750 Hz is a balanced timer frequency. Provides fast interactivity
-	 on desktops with good smoothness without increasing CPU power
-	 consumption and sacrificing the battery life on laptops.
+	 Select 833 Hz as an alternative to 1000 Hz. This choice offers a balance between
+	 latency and performance, providing a slightly lower interrupt frequency that
+	 reduces interrupt overhead and improves system stability. It maintains satisfactory
+	 interactive responsiveness and is suitable for various applications where a
+	 lower interrupt frequency is desired without sacrificing overall system
+	 performance. Examples include audio workstations or video editing systems that
+	 require precise timing while minimizing system overhead.
 
 	config HZ_1000
-		bool "1000 HZ"
+		bool "1000 Hz"
+	help
+	 Select 1000 Hz as the preferred choice for desktop systems and other scenarios
+	 requiring rapid interactive responses. This high frequency ensures excellent
+	 interactive responsiveness and is suitable for applications that require quick
+	 user feedback and real-time interaction, such as graphical applications,
+	 user interfaces, or latency-sensitive tasks. Examples include graphical design
+	 workstations, real-time monitoring systems, or gaming platforms. However, it
+	 may result in increased interrupt overhead and slightly higher power consumption.
+
+	config HZ_1666
+		bool "1666 Hz"
+	help
+	 Select 1666 Hz for systems with low latency requirements. This choice prioritizes
+	 low latency over overall throughput and performance. It offers a snappier feel
+	 in response to interactive processes and is suitable for real-time systems,
+	 latency-sensitive workloads, and applications that demand quick response times,
+	 such as real-time audio or video processing. Examples include audio production
+	 systems, video streaming platforms, or real-time control systems. However, it
+	 may result in increased power consumption and slightly reduced overall system
+	 throughput.
+
+	config HZ_2000
+		bool "2000 Hz"
+	help
+	 Select 2000 Hz for demanding scenarios that require extremely fast timer interrupt
+	 responses. This choice offers exceptional interactive responsiveness and is ideal
+	 for ultra-low latency and real-time applications where precise timing is crucial,
+	 such as high-frequency trading or control systems. Examples include financial
+	 trading platforms or robotics control systems. However, it significantly increases
+	 interrupt overhead, power consumption, system load, and may negatively impact overall
+	 system stability.
+
+	config HZ_5000
+		bool "5000 Hz"
+	help
+	 Select 5000 Hz for specialized systems with stringent real-time requirements.
+	 This choice provides ultra-fast and precise timer interrupt responses, making it
+	 suitable for time-critical applications that require sub-millisecond accuracy,
+	 such as scientific simulations or robotics control. Examples include real-time
+	 simulations, scientific research platforms, or industrial automation systems.
+	 However, it significantly increases interrupt overhead, power consumption, system load,
+	 and may negatively impact overall system stability.
+
+	config HZ_10000
+		bool "10000 Hz"
 	help
-	 1000 Hz is the preferred choice for desktop systems and other
-	 systems requiring fast interactive responses to events.
+	 Select 10000 Hz for extremely high-frequency scenarios that demand ultra-fast and
+	 precise timer interrupt responses. This choice offers exceptional responsiveness
+	 and sub-microsecond accuracy, making it ideal for critical real-time applications,
+	 such as aerospace systems or medical equipment control. Examples include avionics
+	 systems, medical imaging platforms, or high-performance scientific computing.
+	 However, it significantly increases interrupt overhead, power consumption, system load,
+	 and may negatively affect overall system stability. Use with caution.
 
 endchoice
 
@@ -77,7 +152,12 @@ config HZ
 	default 500 if HZ_500
 	default 600 if HZ_600
 	default 750 if HZ_750
+	default 833 if HZ_833
 	default 1000 if HZ_1000
+	default 1666 if HZ_1666
+	default 2000 if HZ_2000
+	default 5000 if HZ_5000
+	default 10000 if HZ_10000
 
 config SCHED_HRTICK
 	def_bool HIGH_RES_TIMERS
diff --git a/kernel/events/core.c b/kernel/events/core.c
index db016e41893199..e64ae6a0304d32 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1063,7 +1063,11 @@ static void perf_cgroup_switch(struct task_struct *task)
  * set default to be dependent on timer tick just
  * like original code
  */
+#if HZ >= 1000
+#define PERF_CPU_HRTIMER (1)
+#else
 #define PERF_CPU_HRTIMER (1000 / HZ)
+#endif
 /*
  * function must be called with interrupts disabled
  */
diff --git a/kernel/rcu/tree_nocb.h b/kernel/rcu/tree_nocb.h
index f2280616f9d51b..ed1f077cb2bed0 100644
--- a/kernel/rcu/tree_nocb.h
+++ b/kernel/rcu/tree_nocb.h
@@ -86,7 +86,7 @@ early_param("rcu_nocb_poll", parse_rcu_nocb_poll);
  * After all, the main point of bypassing is to avoid lock contention
  * on ->nocb_lock, which only can happen at high call_rcu() rates.
  */
-static int nocb_nobypass_lim_per_jiffy = 16 * 1000 / HZ;
+static int nocb_nobypass_lim_per_jiffy = (16 * 1000) / HZ;
 module_param(nocb_nobypass_lim_per_jiffy, int, 0);
 
 /*
